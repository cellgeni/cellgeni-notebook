
```{r}
library(SingleCellExperiment) #object processing
library(scater) #object processing
library(harmony) #Harmony
library(magrittr) #Harmony
library(scran) #mnnCorrect
library(Seurat) #MultiCCA
library(sva) #ComBat
library(limma) #Limma
```

This notebook contains:
• 3 trial 10X datasets
- 1k PBMCs from a Healthy Donor (v2 chemistry)
- 1k PBMCs from a Healthy Donor (v3 chemistry)
- 3k PBMCs from a Healthy Donor (v1 chemistry)

• some QC of these datasets + mergeing
• Batch effect correction tools:
  1) Harmony --> corrects the PCA graph
  2) mnnCorrect --> corrects the expression matrix
  3) multiCCA --> corrects the CC vectors (similar to PCA graph correction)
  4) ComBat --> corrects the expression matrix
  5) Limma --> corrects the expression matrix
•Visualization of the corrected spaces.
  

#load datasets
*Note* --> The function read10xCounts and other similar functions may not recognize the files features.tsv as the gene_names file. Rename to genes.tsv in case of: Error in file(file, "rt") : cannot open the connection. 

If Droplet Utils not installed, install it:
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("DropletUtils", version = "3.8")



```{r}
A_data <- DropletUtils::read10xCounts("/home/jovyan/Ruben_ChG/Vivek_batch_tools/datasets/1k_v2")
B_data <- DropletUtils::read10xCounts("/home/jovyan/Ruben_ChG/Vivek_batch_tools/datasets/1k_v3")
C_data <- DropletUtils::read10xCounts ("/home/jovyan/Ruben_ChG/Vivek_batch_tools/datasets/3k_v1")
```

#QC
• remove those genes expressed in less than 3 cells
• remove those cells with less than 200 genes expressed
```{r initial QC}
datasets <- list(A_data, B_data, C_data)

for (i in 1:length(datasets)){
  datasets[[i]] <- datasets[[i]][apply(counts(datasets[[i]]), 1, function(x) {sum(x>0) >= 3}), apply(counts(datasets[[i]]), 2, function(x){sum(x>0)>=200})]
}
```

```{r calculateQCMetrics}
A_data <- calculateQCMetrics(A_data)
B_data <- calculateQCMetrics(B_data)
C_data <- calculateQCMetrics(C_data)
```
This step may be useful to decide some cutoffs to apply manually in the cell filtering.
```{r QC plots}
hist(A_data$total_counts, breaks = 100, xlab = "Total counts")
hist(A_data$total_features_by_counts, breaks = 100,  xlab = "Total features")
#abline(v = 2500, col = 'red')
plotColData(A_data, y = "total_counts", x = "total_features_by_counts")

hist(B_data$total_counts, breaks = 100, xlab = "Total counts")
hist(B_data$total_features_by_counts, breaks = 100,  xlab = "Total features")
#abline(v = 2500, col = 'red')
plotColData(B_data, y = "total_counts", x = "total_features_by_counts")

hist(C_data$total_counts, breaks = 100, xlab = "Total counts")
hist(C_data$total_features_by_counts, breaks = 100,  xlab = "Total features")
#abline(v = 2500, col = 'red')
plotColData(C_data, y = "total_counts", x = "total_features_by_counts")
```

# CPM normalization
```{r}
#Note: I'm appending to normcounts, but their already log-transformed. So it can be considered logcounts.
normcounts(A_data) <- log2(calculateCPM(A_data, use_size_factors = FALSE, exprs_values = "counts") + 1)
normcounts(B_data) <- log2(calculateCPM(B_data, use_size_factors = FALSE, exprs_values = "counts") + 1)
normcounts(C_data) <- log2(calculateCPM(C_data, use_size_factors = FALSE, exprs_values = "counts") + 1)
```


#merge datasets

In order to merge datasets Matrices must have same number of rows.So we find the common genes to all datasets and subset by them.
```{r gene_names}
#ensembl annotation
common_genes <- rowData(C_data)$ID[rowData(C_data)$ID %in% rowData(B_data)$ID[rowData(B_data)$ID %in% rowData(A_data)$ID]]

length(common_genes)

#classical annotation differs between A_data or B_data with C_data (3k_v1), but genes are the same (same ENS annotation), so I'll append classical gene names later.
rowData(C_data)$Symbol <- NULL
```
```{r}
A_data <- A_data[common_genes,]
B_data <- B_data[common_genes,]
C_data <- C_data[common_genes,]
```


```{r}
combined_normcounts <- cbind(normcounts(A_data), normcounts(B_data), normcounts(C_data))

dataset_labels <- rep(c("A", "B", "C"), times = c(ncol(A_data), ncol(B_data), ncol(C_data)))

cell_names <- c(paste("A-cell", c(1:ncol(A_data))),
                paste("B-cell", c(1:ncol(B_data))),
                paste("C-cell", c(1:ncol(C_data))))

#colData dataframe
cell_data <- data.frame("dataset" = dataset_labels,
                        "cell_ID" = cell_names)
```

```{r}
merged <- SingleCellExperiment(assay = list(normcounts = combined_normcounts),
                               colData = cell_data,
                               rowData = list("ENS_gene_names" = common_genes,
                                          "classical_gene_names" = rowData(A_data)$Symbol)
)
colnames(merged) <- cell_data$cell_ID
```

```{r recalculate QC metrics for the merged object}
merged<- calculateQCMetrics(merged, exprs_values = "normcounts")
```

#visualize
```{r}
plotPCA(merged,
        exprs_values = "normcounts", 
        colour_by = "dataset")
```

#T00LS
#1) Harmony
```{r Harmony variables}
merged <- runPCA(merged, method = "prcomp", exprs_values = "normcounts", ncomponents = 10)
pca <- merged@reducedDims@listData[["PCA"]]
batch_vector = merged$dataset
```

```{r Run Harmony}
t1 = Sys.time()
harmony_emb <- HarmonyMatrix(pca, batch_vector, theta=4)
t2 = Sys.time()

t2-t1
#save Harmony corrected low_D embedding
merged@reducedDims@listData[['harmony_emb']] <- harmony_emb
```

```{r visualize Harmony}
plotReducedDim(merged,1, colour_by = 'dataset')#PCA embeding
plotReducedDim(merged,2, colour_by = 'dataset')#Harmony corrected embedding
```

#2) mnnCorrect
mnnCorrect corrects batch effects in single-cell expression data using the mutual nearest neighbors method. MNN pairs between batches are considered to define the most similar cells of the same type across batches.

*Note* Iif getting some error, try to load the subsets of merged file as.array().
```{r}
t1 = Sys.time()
corrected <- mnnCorrect(
           as.array(normcounts(merged[, merged$dataset == 'A'])),
           as.array(normcounts(merged[, merged$dataset == 'B'])),
           as.array(normcounts(merged[, merged$dataset == 'C'])),
           k = 30,
          sigma = 0.1,
          cos.norm.in = TRUE,
          svd.dim = 2)
t2 = Sys.time()
t2-t1
```
When performing mnnCorrect, dimnames may be lost for corrected[[2]], [[3]] and so on. So dimnames have to lets add them manyally:
```{r}
colnames(corrected$corrected[[2]]) <- colnames(merged[,merged@colData@listData[["dataset"]] == 'B'])
rownames(corrected$corrected[[2]]) <- rownames(merged[,merged@colData@listData[["dataset"]] == 'B'])
colnames(corrected$corrected[[3]]) <- colnames(merged[,merged@colData@listData[["dataset"]] == 'C'])
rownames(corrected$corrected[[3]]) <- rownames(merged[,merged@colData@listData[["dataset"]] == 'C'])
```

```{r}
assay(merged, "mnn") <- cbind(corrected$corrected[[1]], corrected$corrected[[2]], corrected$corrected[[3]])
```

```{r visualize mnnCorrect}
plotPCA(merged, exprs_values = "normcounts", colour_by= "dataset")
plotPCA(merged, exprs_values = "mnn", colour_by= "dataset")
```

#3) multiCCA (Seurat)

Seurat's multiCCA requires the objects to be corrected, to be given individually, and as Seurat objects. This is why we now convert them.
```{r}
#convert to seurat object
merged_seurat <- Convert(merged, to = "seurat", raw.data.slot = "normcounts", data.slot = "normcounts")
#individualize merged object
A_seurat <- SubsetData(merged_seurat,cells.use = merged_seurat@meta.data[["dataset"]] == "A")
B_seurat <- SubsetData(merged_seurat,cells.use = merged_seurat@meta.data[["dataset"]] == "B")
C_seurat <- SubsetData(merged_seurat,cells.use = merged_seurat@meta.data[["dataset"]] == "C")

dataset_list = list(A_seurat, B_seurat, C_seurat)
```

```{r find variable genes and scale data}
A_seurat <- FindVariableGenes(A_seurat)
A_seurat <- ScaleData(A_seurat)
B_seurat <- FindVariableGenes(B_seurat)
B_seurat <- ScaleData(B_seurat)
C_seurat <- FindVariableGenes(C_seurat)
C_seurat <- ScaleData(C_seurat)
```

```{r genes to use in CCA alingment}
dataset_list <- list(A_seurat, B_seurat, C_seurat)

genes.use <- c()

for (i in 1:length(dataset_list)) {
  genes.use <- c(genes.use, rownames(dataset_list[[i]]@hvg.info)[1:4000])
}

genes.use <- names(which(table(genes.use) > 2))
length(genes.use)

for (i in 1:length(dataset_list)) {
  genes.use <- genes.use[genes.use %in% rownames(dataset_list[[i]]@scale.data)]
}
length(genes.use)
```

```{r run multiCCA}
t1 = Sys.time()
merged_cca <- RunMultiCCA(dataset_list, genes.use = genes.use, num.ccs = 10)
t2 = Sys.time()
t2-t1
```

This function provides a useful plot for evaluating the number of CCs to proceed with in the Seurat alignment workflow.
It is similar to the elbowplot to determine the number PCs.
```{r CC selection}
MetageneBicorPlot(merged_cca, grouping.var = "dataset", dims.eval = 1:10)
```

```{r Optional}
#Calculate the ratio of variance explained by PCA to CCA
merged_cca <- CalcVarExpRatio(object = merged_cca, reduction.type = "pca",
                                       grouping.var = "dataset", dims.use = 1:6)
#Optional: Subset those cells with cutoff calue = accept.low
merged_cca <- SubsetData(merged_cca, subset.name = "var.ratio.pca",
                                           accept.low = 0.5)
```

```{r align cca subspaces of datasets}
t1= Sys.time()
merged_cca <- AlignSubspace(merged_cca,
                                     reduction.type ="cca", #pca aligment can be also done, or both, by c("cca", "pca")
                                     grouping.var = "dataset",
                                     dims.align = 1:5)
t2= Sys.time()
t2-t1
```

```{r visualize CCA alignment}
# CCA before correcting
DimPlot(object = merged_cca, reduction.use = "cca", group.by = "dataset", pt.size = 0.5) 
# CCA After aligning subspaces
DimPlot(object = merged_cca, reduction.use = "cca.aligned", group.by = "dataset", pt.size = 0.5) 
```

# 4) ComBat
```{r ComBat models}
combat_data <- as.matrix(normcounts(merged))
mod_data <- as.data.frame(t(combat_data)) #ISSUE HERE!

# Basic batch removal
mod0 = model.matrix(~ 1, data = mod_data) 
# Preserve biological variability--> In case of a confounded effect!
mod1 = model.matrix(~ merged$dataset, data = mod_data) 
# adjust for total genes detected
mod2 = model.matrix(~ merged$total_features, data = mod_data)
```

```{r run ComBat}
t1 = Sys.time()
assay(merged, "combat") <- ComBat(
    dat = t(mod_data), 
    batch = merged$dataset, 
    mod = NULL,
    par.prior = TRUE,
    prior.plots = FALSE
)
t2 = Sys.time()
t2-t1
```

```{r visualize ComBat}
plotPCA(merged, exprs_values = "normcounts", colour_by = "dataset")
plotPCA(merged, exprs_values = "combat", colour_by = "dataset")
```

#5) Limma

```{r run Limma}
batch_vector <- merged$dataset
assay(merged, "limma") <- removeBatchEffect(x = assay(merged, "normcounts"), batch = batch_vector)
```

```{r visualize Limma}
plotPCA(merged, exprs_values = "normcounts", colour_by = "dataset")

plotPCA(merged, exprs_values = "limma", colour_by = "dataset")
```



